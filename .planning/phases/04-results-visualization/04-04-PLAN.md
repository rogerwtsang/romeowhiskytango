---
phase: 04-results-visualization
plan: 04
type: execute
wave: 3
depends_on: ["04-02", "04-03"]
files_modified:
  - src/gui/widgets/optimization_preview.py
  - src/gui/widgets/__init__.py
autonomous: false

must_haves:
  truths:
    - "User can see ranked list of lineup candidates"
    - "User can view stat breakdown for each candidate"
    - "User can see text diff showing lineup changes"
    - "User can copy lineup candidate to main panel via callback"
  artifacts:
    - path: "src/gui/widgets/optimization_preview.py"
      provides: "Optimization preview widgets"
      exports: ["LineupRankingList", "LineupDiffView"]
      min_lines: 200
  key_links:
    - from: "src/gui/widgets/optimization_preview.py"
      to: "lineup panel callback"
      via: "on_copy callback parameter"
      pattern: "on_copy.*Callable"
---

<objective>
Create optimization preview components for viewing and comparing lineup candidates. Includes ranked list view, expandable stat breakdowns, and text diff for lineup changes.

Purpose: Prepare UI foundation for future lineup optimizer (Phase 5+). Users will be able to view optimizer suggestions, compare them, and copy promising candidates to the main lineup panel.
Output: LineupRankingList and LineupDiffView widgets, ready for optimizer integration
</objective>

<execution_context>
@/home/roger/.claude/get-shit-done/workflows/execute-plan.md
@/home/roger/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-results-visualization/04-CONTEXT.md
@src/gui/widgets/__init__.py
@src/gui/widgets/collapsible_frame.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create optimization preview widgets</name>
  <files>src/gui/widgets/optimization_preview.py, src/gui/widgets/__init__.py</files>
  <action>
1. Create `src/gui/widgets/optimization_preview.py`:

```python
class LineupRankingList(ttk.Frame):
    """
    Ranked list of lineup candidates ordered by expected runs.

    Displays top N lineups from optimizer with:
    - Rank number
    - Expected runs (mean)
    - Confidence interval
    - Expandable stat breakdown
    - Copy-to-panel button
    """

    def __init__(self, parent, on_copy: Optional[Callable[[List[Player]], None]] = None,
                 max_display: int = 10, **kwargs):
        """
        Args:
            parent: Parent widget
            on_copy: Callback when user clicks "Copy" (receives lineup list)
            max_display: Maximum candidates to show (default 10)
        """
        super().__init__(parent, **kwargs)
        self.on_copy = on_copy
        self.max_display = max_display
        self._candidates = []
        self._create_widgets()

    def _create_widgets(self):
        # Header row with columns: Rank, Expected Runs, CI, Actions
        # Scrollable frame for candidate rows
        # Each row: CollapsibleFrame with summary visible, details expandable

    def set_candidates(self, candidates: List[Dict[str, Any]]):
        """
        Set lineup candidates to display.

        Args:
            candidates: List of dicts, each with:
                - lineup: List[Player]
                - expected_runs: float
                - ci_lower: float
                - ci_upper: float
                - stats: Dict (optional detailed stats)
        """
        # Clear existing rows
        # Create new rows for each candidate (up to max_display)
        # If no candidates, show "No candidates available" message

    def _create_candidate_row(self, rank: int, candidate: Dict) -> ttk.Frame:
        """Create a row for a single candidate."""
        # Summary: "#{rank}  {expected_runs:.1f} runs [{ci}]  [Copy] [Details]"
        # Details (collapsed): Full stat breakdown

    def _handle_copy(self, lineup: List):
        """Handle copy button click."""
        if self.on_copy:
            self.on_copy(lineup)


class LineupDiffView(ttk.Frame):
    """
    Shows text diff between two lineups.

    Format: "3<->4, 4<->3" for slot swaps
    or full listing for complex changes.
    """

    def __init__(self, parent, **kwargs):
        super().__init__(parent, **kwargs)
        self._create_widgets()

    def _create_widgets(self):
        # Text widget for diff display
        # Clear button

    def show_diff(self, lineup_a: List[Player], lineup_b: List[Player],
                  label_a: str = "Current", label_b: str = "Proposed"):
        """
        Display diff between two lineups.

        Shows:
        - Slot swaps in compact format (e.g., "3<->4, 4<->3")
        - Players added/removed
        - Summary of changes
        """

    def _compute_diff(self, lineup_a, lineup_b) -> str:
        """Compute human-readable diff string."""
        # Find players in different slots
        # Format as "Player X: slot 3->4"
        # Or compact: "3<->4" for simple swaps

    def clear(self):
        """Clear the diff display."""
```

2. Export both classes from src/gui/widgets/__init__.py:
   ```python
   from .optimization_preview import LineupRankingList, LineupDiffView
   ```

3. Use existing CollapsibleFrame for expandable details in LineupRankingList

NOTE: These widgets are UI-ready but won't have real data until the optimizer is built in a future phase. They should work with mock data for testing and visual verification.
  </action>
  <verify>
```bash
# Type check
mypy src/gui/widgets/optimization_preview.py --ignore-missing-imports

# Verify imports
python -c "from src.gui.widgets import LineupRankingList, LineupDiffView; print('Imports OK')"

# Test widget creation and basic functionality
python -c "
import tkinter as tk
from src.gui.widgets import LineupRankingList, LineupDiffView
from src.models.player import Player

root = tk.Tk()
root.withdraw()

# Test ranking list creation
copy_called = []
def on_copy(lineup):
    copy_called.append(lineup)
    print(f'Copy callback fired with {len(lineup)} players')

ranking = LineupRankingList(root, on_copy=on_copy)
print('LineupRankingList created OK')

# Test set_candidates with mock data
mock_players = [Player(name=f'Player{i}', ba=0.25, obp=0.32, slg=0.4) for i in range(9)]
ranking.set_candidates([
    {'lineup': mock_players, 'expected_runs': 750, 'ci_lower': 720, 'ci_upper': 780},
    {'lineup': mock_players, 'expected_runs': 745, 'ci_lower': 715, 'ci_upper': 775},
])
print('set_candidates OK')

# Test diff view creation
diff = LineupDiffView(root)
print('LineupDiffView created OK')

# Test show_diff
diff.show_diff(mock_players, mock_players[::-1])
print('show_diff OK')

# Test copy callback (simulate button click if method exposed)
# This verifies the callback wiring
ranking._handle_copy(mock_players)
assert len(copy_called) == 1, 'Copy callback should have been called once'
print('Copy callback wiring OK')

root.destroy()
print('All widget tests passed')
"
```
  </verify>
  <done>
- LineupRankingList widget exists with ranking display
- set_candidates() method populates the list with candidate data
- Copy callback fires when _handle_copy() called
- LineupDiffView widget exists with diff format
- show_diff() displays slot changes between lineups
- Both exported from widgets package
- Widgets handle empty/mock data gracefully
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Phase 4 visualization components:
1. Enhanced histogram with KDE overlay (Plan 01)
2. Win probability and efficiency metrics (Plan 02)
3. Player contribution chart with slot/player toggle (Plan 03)
4. Optimization preview widgets - ranking list and diff view (Plan 04)
  </what-built>
  <how-to-verify>
1. Launch GUI: `python gui.py`
2. Load team data (Setup panel)
3. Build a lineup (Lineup panel)
4. Run a simulation (Run button)
5. Verify in Results panel:
   - Histogram shows smooth KDE curve over bars
   - Mean and median lines visible on histogram
   - Win probability displayed with CI (e.g., "65% [60-70%]")
   - LOB per game displayed (e.g., "6.2 +/- 1.1")
   - RISP shows "--" (placeholder, data not yet tracked)
   - Player contribution chart shows placeholder "Contribution data not available"
   - Toggle buttons (By Slot / By Player) are present but chart shows placeholder
6. Verify no visual regressions:
   - Summary section remains clean and readable
   - Details section expands/collapses correctly
   - Charts resize with window

For optimization preview widgets (mock data test):
```python
import tkinter as tk
from src.gui.widgets import LineupRankingList, LineupDiffView
from src.models.player import Player

root = tk.Tk()
root.title("Optimization Preview Test")

# Mock players
players = [Player(name=f'Player{i}', ba=0.25, obp=0.32, slg=0.4) for i in range(9)]

# Test ranking list
ranking = LineupRankingList(root, on_copy=lambda l: print(f"Copied: {[p.name for p in l]}"))
ranking.pack(fill='both', expand=True, padx=10, pady=5)
ranking.set_candidates([
    {'lineup': players, 'expected_runs': 750, 'ci_lower': 720, 'ci_upper': 780},
    {'lineup': players, 'expected_runs': 745, 'ci_lower': 715, 'ci_upper': 775},
])

# Test diff view
diff = LineupDiffView(root)
diff.pack(fill='x', padx=10, pady=5)
diff.show_diff(players, players[::-1])  # Reversed lineup

root.mainloop()
```
  </how-to-verify>
  <resume-signal>Type "approved" to confirm Phase 4 complete, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
```bash
# Type check all Phase 4 files
mypy src/gui/utils/chart_utils.py src/gui/dashboard/results_panel.py src/gui/widgets/player_contribution_chart.py src/gui/widgets/optimization_preview.py --ignore-missing-imports

# Verify all imports work together
python -c "
from src.gui.utils.chart_utils import create_histogram_with_kde
from src.gui.dashboard.results_panel import ResultsPanel
from src.gui.widgets import PlayerContributionChart, LineupRankingList, LineupDiffView
print('All Phase 4 imports OK')
"
```
</verification>

<success_criteria>
- LineupRankingList shows ranked candidates with expand/collapse
- LineupDiffView shows compact diff between lineups
- Copy-to-panel callback wired correctly and fires when invoked
- All Phase 4 components integrate cleanly
- Visual verification confirms usable UI
</success_criteria>

<output>
After completion, create `.planning/phases/04-results-visualization/04-04-SUMMARY.md`
</output>
