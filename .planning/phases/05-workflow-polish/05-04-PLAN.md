---
phase: 05-workflow-polish
plan: 04
type: execute
wave: 2
depends_on: [05-01]
files_modified:
  - src/gui/models/team_roster.py
  - src/gui/models/__init__.py
  - src/gui/dashboard/setup_panel.py
  - src/gui/dashboard/main_dashboard.py
  - src/gui/utils/config_manager.py
autonomous: true

must_haves:
  truths:
    - "Team represents loaded player collection with stats (e.g., '2024 Blue Jays')"
    - "Roster is subset of team eligible for batting order"
    - "Lineup is specific 9-player batting order from roster"
    - "Multiple lineups can be saved per roster"
    - "Teams can have nicknames"
  artifacts:
    - path: "src/gui/models/team_roster.py"
      provides: "Team, Roster, and Lineup data classes"
      exports: ["Team", "Roster", "Lineup"]
    - path: "src/gui/dashboard/setup_panel.py"
      provides: "Team/Roster navigation UI"
      contains: "Team"
    - path: "src/gui/utils/config_manager.py"
      provides: "Lineup persistence"
      contains: "save_lineup"
  key_links:
    - from: "src/gui/dashboard/main_dashboard.py"
      to: "src/gui/models/team_roster.py"
      via: "Team/Roster/Lineup usage"
      pattern: "(Team|Roster|Lineup)"
---

<objective>
Implement Team/Roster/Lineup data hierarchy for organized lineup management.

Purpose: Enable users to save multiple lineups per team, organize players into rosters, and compare different batting orders systematically.

Output:
- Team/Roster/Lineup data model classes
- UI for navigating between saved lineups
- Lineup persistence (save/load)
- Team nickname support
</objective>

<execution_context>
@/home/roger/.claude/get-shit-done/workflows/execute-plan.md
@/home/roger/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-workflow-polish/05-CONTEXT.md

# Key source files
@src/gui/dashboard/setup_panel.py
@src/gui/dashboard/main_dashboard.py
@src/gui/utils/config_manager.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Team/Roster/Lineup data model</name>
  <files>src/gui/models/team_roster.py, src/gui/models/__init__.py</files>
  <action>
Create new src/gui/models/ directory and team_roster.py:

```
src/gui/models/
  __init__.py
  team_roster.py
```

1. In team_roster.py, define dataclasses:

```python
from dataclasses import dataclass, field
from typing import List, Optional, Dict, Any
from src.models.player import Player

@dataclass
class Lineup:
    """A specific 9-player batting order."""
    name: str  # e.g., "Standard", "Lefty Stack"
    players: List[Optional[Player]] = field(default_factory=lambda: [None]*9)
    created_at: str = ""  # ISO timestamp

    def is_complete(self) -> bool:
        return all(p is not None for p in self.players)

    def to_dict(self) -> Dict[str, Any]:
        return {
            'name': self.name,
            'players': [p.name if p else None for p in self.players],
            'created_at': self.created_at
        }

@dataclass
class Roster:
    """Subset of team players eligible for batting order."""
    name: str  # e.g., "Active Roster", "Playoff Eligible"
    players: List[Player] = field(default_factory=list)
    lineups: List[Lineup] = field(default_factory=list)

    def add_lineup(self, lineup: Lineup):
        self.lineups.append(lineup)

    def get_lineup(self, name: str) -> Optional[Lineup]:
        for lineup in self.lineups:
            if lineup.name == name:
                return lineup
        return None

@dataclass
class Team:
    """Collection of loaded players with stats."""
    code: str  # e.g., "TOR"
    full_name: str  # e.g., "Toronto Blue Jays"
    season: int  # e.g., 2024
    nickname: str = ""  # User-defined nickname
    players: List[Player] = field(default_factory=list)
    rosters: List[Roster] = field(default_factory=list)

    @property
    def display_name(self) -> str:
        if self.nickname:
            return self.nickname
        return f"{self.season} {self.full_name}"

    def add_roster(self, roster: Roster):
        self.rosters.append(roster)

    def get_default_roster(self) -> Roster:
        # Return first roster or create one with all players
        if self.rosters:
            return self.rosters[0]
        default = Roster(name="Full Roster", players=self.players.copy())
        self.add_roster(default)
        return default
```

2. Create src/gui/models/__init__.py:
```python
from src.gui.models.team_roster import Team, Roster, Lineup
__all__ = ['Team', 'Roster', 'Lineup']
```
  </action>
  <verify>
python -c "
from src.gui.models import Team, Roster, Lineup
t = Team(code='TOR', full_name='Toronto Blue Jays', season=2024)
r = Roster(name='Active')
l = Lineup(name='Standard')
t.add_roster(r)
r.add_lineup(l)
print(f'Team: {t.display_name}')
print(f'Roster: {r.name}')
print(f'Lineup: {l.name}')
print('Data model created successfully')
"
  </verify>
  <done>Team, Roster, Lineup dataclasses exist with proper relationships and methods</done>
</task>

<task type="auto">
  <name>Task 2: Add lineup persistence and navigation UI</name>
  <files>src/gui/utils/config_manager.py, src/gui/dashboard/setup_panel.py, src/gui/dashboard/main_dashboard.py</files>
  <action>
1. In config_manager.py, add lineup persistence methods:
   - save_lineup(team_code: str, season: int, lineup_name: str, player_names: List[str])
   - load_lineups(team_code: str, season: int) -> List[Dict]
   - delete_lineup(team_code: str, season: int, lineup_name: str)
   - Store in ~/.montecarlo_baseball/lineups/{team}_{season}.json

2. In setup_panel.py, add team nickname field:
   - Add ttk.Entry for nickname below team selector
   - Label: "Nickname (optional):"
   - Store in self.team_nickname

3. In main_dashboard.py, integrate Team model:
   - Replace self.roster with self.current_team: Optional[Team]
   - Update _on_data_loaded() to create Team object
   - Add Team display name in header or sidebar

4. Add lineup navigation (simple dropdown for now):
   - ttk.Combobox listing saved lineups for current team/season
   - "Save Lineup" button to save current lineup with name
   - "Load Lineup" button to restore selected lineup
   - Place in simulation_panel header or lineup_panel footer

Note: Full tree view navigation is Claude's discretion per CONTEXT.md. Simple dropdown is acceptable MVP.
  </action>
  <verify>
python -c "
from src.gui.utils.config_manager import ConfigManager
cm = ConfigManager()
# Test save/load cycle
cm.save_lineup('TOR', 2024, 'Test', ['Player1', 'Player2'])
lineups = cm.load_lineups('TOR', 2024)
print(f'Saved lineups: {len(lineups)}')
cm.delete_lineup('TOR', 2024, 'Test')
print('Lineup persistence working')
"
  </verify>
  <done>Team/Roster/Lineup hierarchy integrated, lineups can be saved/loaded, team nicknames supported</done>
</task>

</tasks>

<verification>
1. Launch GUI: `python gui.py`
2. Load a team (e.g., TOR 2024)
3. Enter a nickname - verify it displays correctly
4. Build a lineup, click "Save Lineup"
5. Enter name "Standard" - verify lineup is saved
6. Clear lineup, select "Standard" from dropdown, click "Load"
7. Verify lineup is restored
8. Build different lineup, save as "Lefty Stack"
9. Verify both lineups appear in dropdown
</verification>

<success_criteria>
- Team/Roster/Lineup data model correctly represents hierarchy
- Lineups persist to disk and reload across sessions
- Team nicknames display instead of default name when set
- Lineup navigation dropdown allows switching between saved lineups
</success_criteria>

<output>
After completion, create `.planning/phases/05-workflow-polish/05-04-SUMMARY.md`
</output>
